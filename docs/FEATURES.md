# Special Features Documentation

This document details the custom features implemented in this NixOS configuration that make it unique and user-friendly.

## ğŸ”§ Automatic Hardware Configuration Detection

### Problem Solved

When using Git to manage NixOS configurations across multiple machines, the hardware-configuration.nix file presents a challenge:
- It contains machine-specific UUIDs for disk partitions
- It's auto-generated by `nixos-generate-config`
- Pulling from Git overwrites local hardware settings
- This can make systems unbootable

### Our Solution

We've implemented an intelligent hardware configuration wrapper that:

1. **Detects the build context** - Determines if running locally or from Git
2. **Auto-selects configuration** - Uses `/etc/nixos/hardware-configuration.nix` when available
3. **Provides fallback** - Includes a placeholder for Git storage
4. **Requires `--impure` flag** - Enables access to system files outside the flake

### How It Works

The `hardware-config.nix` module:

```nix
{ config, lib, pkgs, ... }:

let
  hasSystemConfig = builtins.pathExists /etc/nixos;
  
  hardwareImport = 
    if hasSystemConfig && builtins.pathExists /etc/nixos/hardware-configuration.nix
    then /etc/nixos/hardware-configuration.nix
    else ./hardware-configuration.nix;
in
{
  imports = [ hardwareImport ];
}
```

### Usage

Always rebuild with the `--impure` flag:

```bash
sudo nixos-rebuild switch --flake .#hydenix --impure
```

### Benefits

- âœ… **No manual copying** - Hardware config is automatically detected
- âœ… **Git-friendly** - Pull without breaking your system
- âœ… **Multi-machine support** - Each machine keeps its own hardware settings
- âœ… **Zero maintenance** - Set up once and forget

## ğŸ”„ Auto-Commit to GitHub

### Purpose

Automatically backs up your configuration changes to GitHub, ensuring:
- Configuration history is preserved
- Changes are never lost
- Easy rollback if needed
- Synchronization across machines

### How It Works

The auto-commit module runs during system activation and:

1. **Checks for changes** - Detects uncommitted modifications
2. **Commits automatically** - Creates timestamped commits
3. **Pushes to GitHub** - Uses `gh` CLI for authentication
4. **Handles errors gracefully** - Continues rebuild even if push fails

### Implementation

Located in `/nix-modules/modules/system/auto-commit.nix`:

```nix
system.activationScripts.autoCommitChanges = lib.mkAfter ''
  cd /nix-modules
  
  if [ -n "$(git status --porcelain 2>/dev/null)" ]; then
    git config user.email "noreply@github.com"
    git config user.name "NixOS Auto-Commit"
    
    git add -A
    TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
    git commit -m "Auto-commit: NixOS rebuild at $TIMESTAMP"
    
    gh repo sync --branch main || echo "Push failed - run 'gh auth login'"
  fi
'';
```

### Configuration

1. **Enable GitHub CLI authentication**:
   ```bash
   gh auth login
   ```

2. **Verify auto-commit is working**:
   ```bash
   # Make a change
   echo "test" | sudo tee /nix-modules/test.txt
   
   # Rebuild
   sudo nixos-rebuild switch --flake .#hydenix --impure
   
   # Check GitHub
   ```

3. **Disable if needed**:
   Remove from `configuration.nix`:
   ```nix
   # ./modules/system/auto-commit.nix  # Comment out
   ```

### Benefits

- ğŸ”’ **Automatic backups** - Never lose configuration changes
- ğŸ“ **Change history** - Track what changed and when
- ğŸ”„ **Easy sync** - Pull changes on other machines
- â±ï¸ **Timestamped commits** - Know exactly when changes were made

## ğŸ¨ Hydenix Integration

### What is Hydenix?

Hydenix is a comprehensive NixOS configuration framework that provides:
- Pre-configured Hyprland window manager
- Beautiful themes and animations
- Integrated development tools
- Optimized desktop experience

### Features Included

1. **Window Management**
   - Dynamic tiling with Hyprland
   - Smooth animations and transitions
   - Workspace management
   - Multi-monitor support

2. **User Interface**
   - Waybar status bar
   - Rofi application launcher
   - Notification system (mako/dunst)
   - Screenshot/recording tools

3. **Development Tools**
   - Terminal emulators (Kitty, Alacritty)
   - Code editors integration
   - Git utilities
   - Development environments

4. **Theming**
   - Catppuccin color schemes
   - Consistent GTK/Qt theming
   - Icon themes
   - Cursor themes

### Configuration

In `configuration.nix`:

```nix
hydenix = {
  enable = true;
  hostname = "your-hostname";
  timezone = "Your/Timezone";
  locale = "en_US.UTF-8";
};
```

In Home Manager modules:

```nix
hydenix.hm = {
  enable = true;
  theme = {
    flavor = "mocha";
    accent = "blue";
  };
};
```

## ğŸ—ï¸ Modular Architecture

### Structure

```
/nix-modules/
â”œâ”€â”€ configuration.nix        # Main system configuration
â”œâ”€â”€ hardware-config.nix      # Hardware detection wrapper
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ system/             # System-level modules
â”‚   â”‚   â”œâ”€â”€ auto-commit.nix
â”‚   â”‚   â””â”€â”€ [custom modules]
â”‚   â””â”€â”€ hm/                 # Home Manager modules
â”‚       â”œâ”€â”€ default.nix
â”‚       â””â”€â”€ programs/
```

### Benefits

1. **Separation of Concerns**
   - System vs user configuration
   - Hardware vs software settings
   - Core vs optional features

2. **Reusability**
   - Share modules between machines
   - Import only what's needed
   - Easy to enable/disable features

3. **Maintainability**
   - Clear file organization
   - Easy to find configurations
   - Simple to add new features

### Creating Custom Modules

Example system module:

```nix
# modules/system/my-feature.nix
{ config, lib, pkgs, ... }:

with lib;
let
  cfg = config.myFeature;
in {
  options.myFeature = {
    enable = mkEnableOption "my custom feature";
    
    setting = mkOption {
      type = types.str;
      default = "default-value";
      description = "A custom setting";
    };
  };
  
  config = mkIf cfg.enable {
    # Implementation here
  };
}
```

## ğŸ” Security Considerations

### Implemented Security Measures

1. **No secrets in Git**
   - Hardware UUIDs kept local
   - Passwords not committed
   - SSH keys excluded

2. **Permission management**
   - System files require sudo
   - User files isolated
   - Proper group assignments

3. **Automatic updates**
   - Regular flake updates
   - Security patches included
   - Easy rollback if needed

### Best Practices

1. **Change default passwords**
   ```bash
   passwd  # Change user password
   ```

2. **Use secrets management**
   ```nix
   # Use age or sops-nix for secrets
   sops.secrets."myservice/password" = {};
   ```

3. **Regular updates**
   ```bash
   sudo nix flake update
   sudo nixos-rebuild switch --flake .#hydenix --impure
   ```

## ğŸš€ Performance Optimizations

### Implemented Optimizations

1. **Binary caches**
   - NixOS official cache
   - Hydenix cache
   - Reduced build times

2. **Parallel building**
   - Uses all CPU cores
   - Faster compilation
   - Optimized for modern hardware

3. **Smart rebuilds**
   - Only rebuilds changed components
   - Incremental updates
   - Minimal downtime

### Configuration

```nix
nix.settings = {
  # Binary caches
  substituters = [
    "https://cache.nixos.org"
    "https://hydenix.cachix.org"
  ];
  
  # Parallel builds
  max-jobs = "auto";
  cores = 0;
  
  # Optimization
  auto-optimise-store = true;
};
```

## ğŸ“Š Monitoring and Debugging

### Built-in Tools

1. **System status**
   ```bash
   systemctl status
   journalctl -xe
   ```

2. **Configuration debugging**
   ```bash
   nixos-rebuild build --show-trace
   nix repl '<nixpkgs/nixos>'
   ```

3. **Generation management**
   ```bash
   sudo nix-env --list-generations -p /nix/var/nix/profiles/system
   ```

### Troubleshooting Features

1. **Automatic rollback**
   - GRUB menu shows previous generations
   - Easy recovery from bad configurations

2. **Dry runs**
   ```bash
   sudo nixos-rebuild dry-activate --flake .#hydenix --impure
   ```

3. **Build without switching**
   ```bash
   sudo nixos-rebuild build --flake .#hydenix --impure
   ```

---

*These features make this NixOS configuration robust, user-friendly, and suitable for both beginners and advanced users.*
